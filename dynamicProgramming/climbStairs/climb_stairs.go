package climbStairs

/*
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？



示例 1：
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶

示例 2：
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶


提示：

1 <= n <= 45

动态规划：
最后一步：要么跨两阶，要么跨一阶，这里有两种方案，而我们要求的是，这两种方案的爬楼方法的总数，所以可以得出递推公式

f(n) = f(n-1) + f(n-2)

f(n)=总的爬楼方法数
f(n-1)=最后一步，跨一阶的总方法数
f(n-2)=最后一步，跨两阶的总方法数

根据给出的例子可以知道
当n=1时，只有一种方法，f(n=1)=1
当n=2时，有两种方法，f(n=2)=2
当n=3时，f(n=3)=f(n=2)+f(n=1)=3
以此类推......
当n=4时，f(n=4)=f(n=3)+f(n=2)=5
当n=5时，f(n=5)=f(n=4)+f(n=3)=8
问题解决

*/

func ClimbStairs(n int) int {
	if n == 1 {
		return 1
	}
	if n == 2 {
		return 2
	}

	// 初始化前两个台阶的方法数
	first, second := 1, 2
	for i := 3; i <= n; i++ {
		first, second = second, first+second
	}
	return second
}
